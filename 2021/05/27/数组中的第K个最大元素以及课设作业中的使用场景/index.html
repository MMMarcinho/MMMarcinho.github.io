<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Marco's Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="方正 Marco" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Marco</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/mmmarco" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="https://www.zju.edu.cn" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://z3.ax1x.com/2021/06/10/22SGZQ.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >LeetCode - 215.数组中的第K个最大元素以及课设作业中的使用场景</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h2 id="LeetCode-215-数组中的第K个最大元素以及课设作业中的使用场景"><a href="#LeetCode-215-数组中的第K个最大元素以及课设作业中的使用场景" class="headerlink" title="LeetCode 215 - 数组中的第K个最大元素以及课设作业中的使用场景"></a>LeetCode 215 - 数组中的第K个最大元素以及课设作业中的使用场景</h2><p>今年找实习的时候刷题做到了一道很热门的考题——取数组前k大的数。</p>
<p>这道题是一道思路并不困难的题目，拿到题目的第一眼我就明白最好的解决方法就是先对数组进行排序，再取前k大的值即可。这道题和 LeetCode <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a> 基本一致，所以此处可以用这道题目来讲解。</p>
<pre><code class="c++">215. 数组中的第K个最大元素
在未排序的数组中找到第 k 个最大的元素。
请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
示例 1:  输入: [3,2,1,5,6,4] 和 k = 2   输出: 5   
示例 2:  输入: [3,2,3,1,2,4,5,5,6] 和 k = 4   输出: 4
说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。
</code></pre>
<p>当时在解题的过程中，我使用了最简单的方法，就是使用STL的 sort() 方法。使用 sort() 之后，整个解题非常简单，只需要两三行代码即可。</p>
<pre><code class="c++">class Solution &#123;
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;
        sort(nums.begin(), nums.end());
        return nums[nums.size() - k];
    &#125;
&#125;;
</code></pre>
<p>但是面试的时候肯定不是让我来耍STL的函数的，本道题目实际上考的就是如何对数组进行排序。排序在数据结构的课上就学过很多种方法，比较简单的例如选择排序、插入排序、冒泡排序等都是常用的排序方法，而快速排序、堆排序、希尔排序、归并排序这些较为复杂的排序法才是在面试笔试过程中比较容易考到的。所以此处我以<strong>快速排序</strong>和<strong>堆排序</strong>为例来展示如何解决这道问题。</p>
<pre><code class="c++">class Solution &#123;
public:
    /* 快排思想的步骤：
    1. 随机确定一个基准值 
    2. 小数放左，大数放右 
    3. 检查当前值的位置 
       等于 k-1 当前数就是第K大 target
       小于 k-1 target在右区间
       大于 k-1 target在左区间
    4. 在目标区间继续寻找 */
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;
        int n = nums.size(), start = 0, end = nums.size() - 1;
        return findFunction(nums, n - k, start, end);
    &#125;

    int findFunction(vector&lt;int&gt;&amp; nums, int k, int start, int end)&#123;
        int p = rand() % (end - start + 1) + start; // 随机取一个基准
        swap(nums[p], nums[end]);
        p = end; // 将基准放在最后一个位置
        int curVal = nums[p], left = start, right = end - 1;
        
        if (start == end &amp;&amp; start == k) 
            return nums[start]; // 如果相等，则当前数就是第K大 target

        while(left &lt; right)&#123; // 循环找到left和right符合条件的值并交换
            while(left &lt; right &amp;&amp; nums[left] &lt; curVal)
                left ++; // 若小于则增加left

            while(left &lt; right &amp;&amp; nums[right] &gt;= curVal)
                right--; // 若大于则减小right

            if(left &lt; right)
                swap(nums[left], nums[right]); // 只要left小于right，则交换left和right下标的数值
        &#125;

        if (nums[right] &lt; curVal) 
            right++; // 如果此时right的值还是小于curVal则将right再加一
        swap(nums[right], nums[end]); // 交换right和end的值
        p = right; // 将p指向right
        if(p == k) // 若p就等于k，则说明当前值就是第k大的值
            return nums[p];
        // 若小于则说明target的值在当前的右边区间，若小于则target在当前的左边区间
        return p &lt; k ? findFunction(nums, k, right+1, end) : findFunction(nums, k, start, right-1);
    &#125;
&#125;;
</code></pre>
<p>以上是使用快排的方法进行排序。快排的方法最大的缺点是 <del>不容易记住</del> 在基本有序的情况下，会出现很消耗极大的时间的情况，但是平均性能较好，时间复杂度是O(N * log K)。然后接下来是一个在数据结构课上并没有着重介绍的堆排序的方法。</p>
<p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。建立一个大根堆，做 k − 1 次删除操作后堆顶元素就是我们要找的答案。虽然使用优先队列可以直接实现堆容器的建立，但是面试时能自己建立大顶堆则是一个明显的加分项</p>
<pre><code class="c++">class Solution &#123;
public:
    void maxHeapify(vector&lt;int&gt;&amp; a, int i, int heapSize) &#123; // 首先定义大顶堆的排序操作
        int left = i * 2 + 1, right = i * 2 + 2, largest = i;
        if (left &lt; heapSize &amp;&amp; a[left] &gt; a[largest])
            largest = left; // 将最大值的下标定在左边
        if (right &lt; heapSize &amp;&amp; a[right] &gt; a[largest])
            largest = right; // 将最大值的下标定在右边
        if (largest != i) &#123;
            swap(a[i], a[largest]); // 交换最大值与下标i的值
            maxHeapify(a, largest, heapSize);
        &#125;
    &#125;

    void buildMaxHeap(vector&lt;int&gt;&amp; a, int heapSize) &#123; // 建立大顶堆
        for (int i = heapSize / 2; i &gt;= 0; i --)
            maxHeapify(a, i, heapSize); // 从数组的中间值开始，每个进行操作
    &#125;

    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;
        int heapSize = nums.size(); // 获取堆的长度大小
        buildMaxHeap(nums, heapSize); // 首先进行大顶堆的建立
        for (int i = nums.size() - 1; i &gt;= nums.size() - k + 1; i --) &#123;
            swap(nums[0], nums[i]); // 交换首位和第i位的值
            heapSize --; // 堆的长度减一
            maxHeapify(nums, 0, heapSize); // 从第0位开始，进行堆排序的操作
        &#125;
        return nums[0];
    &#125;
&#125;;

// 作者：LeetCode-Solution
</code></pre>
<p>堆排序的时间复杂度为 O(N logN)，但堆排序存在一个很大的问题 —— 堆的维护问题，实际场景中的数据是频繁发生变动的，而对于待排序序列的每次的增删改查回导致堆的维护需要重新进行一次，这在大多数情况下都是没有必要的。所以我们在实际情况中基本使用的还是快速排序。</p>
<p>在我们本学期学习的软件工程大作业中，我们做了一个缘分匹配系统。缘分匹配系统，自然需要进行一个基础的匹配。但是匹配是存在一定难度的，因为我们后端只会一些基础的操作，很难根据同学自己写入的自我介绍分割关键词并进行加权匹配。所以我们采取了一个很简单但是很好用的方法，就是将每一个同学建立一个匹配编码，该编码仅包括1和0。例如下图，在同学感兴趣的方面我们则设置为 1，不感兴趣的方面则设置为 0。</p>
<p><img src="https://z3.ax1x.com/2021/06/10/22pSeg.jpg" alt="img"></p>
<p>所以我们可以获得每个人都有一个用于匹配的编码。例如Jack可以根据他的填写获得的匹配码为 1010 1001 0011，而Rose根据填写获得了 1101 1111 0001。所以使用按位 <strong>同或 xnor</strong> （也可以使用 <strong>与 and</strong> ） 操作，可以获得Jack和Rose之间有哪些共同的兴趣点。若是对Jack进行匹配，则先让Jack的匹配码与每位同学的匹配码进行匹配，获得一个匹配后的值。每个进行匹配的同学与Jack都会有一个匹配值，此时只要对匹配值进行一个排序，再筛选出前8大的值，即可找出与Jack最匹配的8位同学。</p>
<p><img src="https://z3.ax1x.com/2021/06/10/22SxOS.png" alt="img2"></p>
<p>所以此时在编写代码的过程中就发现，取前K大的值其实是一个非常常用的算法问题，而快排则是一个非常好的解决方案，网上对快排有很多种优化的方案，最优秀的方案可以把时间复杂度降低到O(N)，此处暂略不表。</p>

            </div>

            <!-- Post Comments -->
            

        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
