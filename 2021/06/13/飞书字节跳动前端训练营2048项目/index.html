<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Marco's Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="方正 Marco" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Marco</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/mmmarco" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="https://www.zju.edu.cn" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://z3.ax1x.com/2021/06/10/2RGjHO.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >JavaScript - 飞书字节跳动前端训练营2048项目前端实现难点</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h3 id="2048项目GitHub仓库点这里"><a href="#2048项目GitHub仓库点这里" class="headerlink" title="2048项目GitHub仓库点这里"></a><a target="_blank" rel="noopener" href="https://github.com/caizhenghai/2048ForGroup13">2048项目GitHub仓库点这里</a></h3><h3 id="2048项目Bilibili演示视频点这里"><a href="#2048项目Bilibili演示视频点这里" class="headerlink" title="2048项目Bilibili演示视频点这里"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1x541157Dt">2048项目Bilibili演示视频点这里</a></h3><p>2020年11月，机缘巧合下看到了飞书（上海）在举办一个飞书字节跳动前端训练营，抱着试一试的态度去报了名结果很幸运地通过了筛选（四道题目的笔试，其中有一题我还不会做，有空一定写清楚了）。当时训练营布置的项目任务是小组成员完成一个2048小游戏，因为当时我稍微有一些前端开发的经验，于是就主要由我负责前端方面。</p>
<p>虽然一开始的本意是使用React进行一个搭建，但是因为小组里面其他负责前端的同学对这方面并不熟悉，并迅速找到了一个不错的可以运行的版本，于是就决定在给出的Demo基础上进行创新更改。没想到，最困难的事情是这个Demo是基于JQuery的，而我并没有接触过这方面的技术，可以说是又要重新学习一下这个“远古”的技术。</p>
<h3 id="项目实现难点"><a href="#项目实现难点" class="headerlink" title="项目实现难点"></a>项目实现难点</h3><p>根据飞书给出的要求，我们从中选取了几个作为我们小组项目目标实现的功能，主要有以下几个：</p>
<ul>
<li>实现双方对战，可以展示对手此时的棋盘</li>
<li>对战时实时展示比分的分数和排名</li>
<li>在达到特定值的时候进行惩罚，减半对手的最大值</li>
<li>在对手达到特定状态（例如获得了某个值的时候）展示消息</li>
</ul>
<p>这几个要求理论上难度并不大，但是对于从未上手练习过 JQuery 的我来说其实难度不小。因为我当时主要学习的还是小程序端的开发，所以我在开发的过程中对生命周期函数的要求特别高，依赖程度也很大。但是我并没有接触过JQuery的生命周期函数，所以操作起来并不轻松。</p>
<ol>
<li><h4 id="完成用户间通讯"><a href="#完成用户间通讯" class="headerlink" title="完成用户间通讯"></a>完成用户间通讯</h4><p>这一块主要由服务端的同学来进行负责，所以其实我参与得并不多。</p>
<pre><code class="javascript">/*发送数据到服务器端*/
function sendScore(name,score,arr,max,max_x,max_y) &#123;
    /* 提取arr */
    var playBoard=new Array();
    var i, j;
    for (i = 0; i &lt; 4; i++) &#123;
        playBoard[i] = new Array();
        for (j = 0; j &lt; 4; j++) &#123;
            playBoard[i][j]=arr[i][j].value;
        &#125;
    &#125;

    console.log(JSON.stringify(&#123;
        &#39;name&#39;: name,
        &#39;score&#39;: score,
        &#39;playboard&#39;:playBoard,
        &#39;max&#39;:max,
        &#39;max_x&#39;:max_x,
        &#39;max_y&#39;:max_y,
        &#39;timeStamp&#39;: (new Date().getTime() - startTime)
    &#125;));
    stompClient.send(&quot;/app/hello&quot;, &#123;&#125;, JSON.stringify(&#123;
        &#39;name&#39;: name,
        &#39;score&#39;: score,
        &#39;playBoard&#39;:playBoard,
        &#39;max&#39;:max,
        &#39;max_x&#39;:max_x,
        &#39;max_y&#39;:max_y,
        &#39;timeStamp&#39;: (new Date().getTime() - startTime)
    &#125;));
&#125;
</code></pre>
<p>可以看到，此处互相交互的方法主要是采用了JSON的格式，与后台的联系也很方便。</p>
</li>
<li><h4 id="展示对手的实时棋盘"><a href="#展示对手的实时棋盘" class="headerlink" title="展示对手的实时棋盘"></a>展示对手的实时棋盘</h4><p>此处展示对手的棋盘就首先要在自己的页面上绘制一个区域放置它。</p>
<pre><code class="html">&lt;!-- 对手视图 --&gt;
&lt;div class=&quot;cell_wrap2&quot;&gt;
    &lt;div class=&quot;box2&quot;&gt;
        &lt;div class=&quot;cell2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;cell2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;cell2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;cell2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;cell2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;cell2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;cell2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;cell2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;cell2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;cell2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;cell2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;cell2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;cell2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;cell2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;cell2&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;cell2&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>这个编写的方法看似有点蠢，但实际上对于初学的我来说，上手难度就低了很多了。</p>
<pre><code class="javascript">/*每当对方做出操作，更新缩略图*/
function updateBoard()&#123;
    var opponentBoard=new Array();
    /*判断一下哪个是对手的游戏盘*/
    var i,j;
    /*若当前页面的名字不等于myList[0].name，则myList[0].playBoard是对手的游戏盘（4*4的二维数组）*/
    if(myList[0].name!=g.name)&#123;
        for(i=0;i&lt;4;i++)&#123;
            opponentBoard[i]=new Array();
            for(j=0;j&lt;4;j++)
                opponentBoard[i][j]=myList[0].playBoard[i][j];
        &#125;
    &#125;
    else&#123; /*反之，myList[1].playBoard是对手的游戏盘*/
        for(i=0;i&lt;4;i++)&#123;
            opponentBoard[i]=new Array();
            for(j=0;j&lt;4;j++)
                opponentBoard[i][j]=myList[1].playBoard[i][j];
        &#125;
    &#125;

    /*画出对手的缩略图*/
    for(i=0;i&lt;4;i++) &#123;
        for(j=0;j&lt;4;j++)&#123;
            var item =
                        &#39;&lt;div class=&quot;number_cell2 spos&#39; + i +
                        j + &#39;&quot; &gt;&lt;a class=&quot;number_cell_con2 sn&#39; +
                        0 +
                        &#39;&quot;&gt;&lt;div class=&quot;span_wrap2&quot;&gt;&lt;span&gt;&#39; +
                        0 +
                        &quot;&lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;&quot;;
                        $(&quot;.box2&quot;).append(item);
        &#125;
    &#125;
    for (i = 0; i &lt; 4; i++) &#123;
          for (j = 0; j &lt; 4; j++) &#123;
            var item = &#39;&lt;div class=&quot;number_cell2 spos&#39; + i +
                       j + &#39;&quot; &gt;&lt;a class=&quot;number_cell_con2 sn&#39; +
                      opponentBoard[i][j] +
                      &#39;&quot;&gt;&lt;div class=&quot;span_wrap2&quot;&gt;&lt;span&gt;&#39; +
                      opponentBoard[i][j] +
                     &quot;&lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;&quot;;
            $(&quot;.box2&quot;).append(item);
          &#125;
    &#125;
&#125;
</code></pre>
<p>可以看到，我成功将生成的item放到了box2结点里面，但实际上我虽然是完成了任务，在绘制过程中频繁调用修改了DOM，所以效率上实际上是惨不忍睹。</p>
<p><img src="https://z3.ax1x.com/2021/06/10/2RQQv8.png"></p>
</li>
<li><h4 id="根据双方信息，展示排行榜"><a href="#根据双方信息，展示排行榜" class="headerlink" title="根据双方信息，展示排行榜"></a>根据双方信息，展示排行榜</h4><p>因为排行是一个动态更新的过程，所以理论上要每一次通讯的时候就进行一次监听。</p>
<pre><code class="javascript">/* 更新前端排行榜 */
function updateRanking()&#123;
    var tmplist=myList; //玩家列表
    /*mylist（两个人）*/
    if(myList.length==2)&#123;
        if(parseFloat(tmplist[0].score)&lt;parseFloat(tmplist[1].score))&#123;
            document.getElementById(&quot;rank_1&quot;).innerHTML=&quot;1&quot;;
            document.getElementById(&quot;rankName_1&quot;).innerHTML=tmplist[1].name;
            document.getElementById(&quot;rankScore_1&quot;).innerHTML=tmplist[1].score;
            document.getElementById(&quot;rank_2&quot;).innerHTML=&quot;2&quot;;
            document.getElementById(&quot;rankName_2&quot;).innerHTML=tmplist[0].name;
            document.getElementById(&quot;rankScore_2&quot;).innerHTML=tmplist[0].score;
        &#125;else&#123;
            document.getElementById(&quot;rank_2&quot;).innerHTML=&quot;2&quot;;
            document.getElementById(&quot;rankName_2&quot;).innerHTML=tmplist[1].name;
            document.getElementById(&quot;rankScore_2&quot;).innerHTML=tmplist[1].score;
            document.getElementById(&quot;rank_1&quot;).innerHTML=&quot;1&quot;;
            document.getElementById(&quot;rankName_1&quot;).innerHTML=tmplist[0].name;
            document.getElementById(&quot;rankScore_1&quot;).innerHTML=tmplist[0].score;
        &#125;
    &#125;/*mylist（一个人）*/
    else&#123;
        document.getElementById(&quot;rank_1&quot;).innerHTML=&quot;1&quot;;
        document.getElementById(&quot;rankName_1&quot;).innerHTML=tmplist[0].name;
        document.getElementById(&quot;rankScore_1&quot;).innerHTML=tmplist[0].score;
    &#125;
&#125;
</code></pre>
<p>上述方法可以说很简单地就实现了排行的更新，但是一旦进行双人游戏，每次移动都会造成至少6次修改DOM，非常低效，所以应当使用一定的办法减少对DOM的操作。</p>
<pre><code class="javascript">/* 更新前端排行榜 */
function updateRanking()&#123;
    var tmplist=myList; //玩家列表
    if(myList.length === 1) &#123;
        document.getElementById(&quot;rankName_1&quot;).innerHTML=tmplist[0].name;
         document.getElementById(&quot;rankScore_1&quot;).innerHTML=tmplist[0].score;
    &#125; else &#123;
        let topName = document.getElementById(&quot;rankName_1&quot;).innerHTML;
        if ( (parseFloat(tmplist[0].score) &lt; parseFloat(tmplist[1].score)
            &amp;&amp; String(topName) === tmplist[1].name) || 
           (parseFloat(tmplist[0].score) &gt; parseFloat(tmplist[1].score)
            &amp;&amp; String(topName) === tmplist[0].name) ) 
        &#123; // 因为排名和之前相同，所以不更新排名，仅更新分数
           document.getElementById(&quot;rankScore_1&quot;).innerHTML = tmplist[1].score;
            document.getElementById(&quot;rankScore_2&quot;).innerHTML = tmplist[0].score;
        &#125;
        else
        &#123; // 因为排名发生了变化，所以要更新名字和分数
             document.getElementById(&quot;rankName_1&quot;).innerHTML = tmplist[1].name;
            document.getElementById(&quot;rankName_0&quot;).innerHTML = topName;
            document.getElementById(&quot;rankScore_1&quot;).innerHTML=tmplist[1].score;
            document.getElementById(&quot;rankScore_2&quot;).innerHTML=tmplist[0].score;
        &#125;
    &#125;
&#125;
</code></pre>
<p>虽然进行了一定程度的优化，但实际上还是要控制3.5次DOM，虽然相较之前有所好转，但还是效率过低。所以以后进行项目技术选型的时候，确实应该把 React 或 Vue 优先考虑。</p>
</li>
<li><h4 id="进行惩罚（减小最大值）功能编写"><a href="#进行惩罚（减小最大值）功能编写" class="headerlink" title="进行惩罚（减小最大值）功能编写"></a>进行惩罚（减小最大值）功能编写</h4><p>惩罚功能实际上就是对面达到某个值的时候将自己的最大值减半，反之亦然。</p>
<p>完成这项功能需要多个函数配合工作</p>
<p>锁定最大值位置函数</p>
<pre><code class="javascript">// 得到最大的单元格的位置和大小
  Get_Max_Num: function () &#123;
    var i, j, temp;
    temp = this.Max_Num;
    for (i = 0; i &lt; 4; i++) &#123;
      for (j = 0; j &lt; 4; j++) &#123;
        if (temp &lt;= this.arr[i][j].value) &#123;
          temp = this.arr[i][j].value;
          this.Max_Num = temp;
          this.Max_Num_x = i;
          this.Max_Num_y = j;
        &#125;
      &#125;
    &#125;
  &#125;,
</code></pre>
<p>减半最大值函数</p>
<pre><code class="javascript">  Punish: function (Max_Num_x, Max_Num_y) &#123;
    this.arr[Max_Num_x][Max_Num_y].value = this.arr[Max_Num_x][Max_Num_y].value / 2;
    this.drawCell(Max_Num_x, Max_Num_y);
  &#125;,
</code></pre>
<p>通知函数</p>
<pre><code class="javascript">Punish_Notice: function () &#123;
    var item =
      &#39;&lt;div class=&quot;news_head&quot;&gt;警告&lt;/div&gt;&#39; +
      &#39;&lt;div class=&quot;news_content&quot;&gt;你的最大值被干掉了 ╥﹏╥&lt;/div&gt;&#39;;
    $(&quot;.news&quot;).append(item);
    setTimeout(function () &#123;
      $(&quot;.news&quot;).empty(item);
    &#125;, 2000);
  &#125;,
</code></pre>
<p>绘制新棋盘函数</p>
<pre><code class="javascript">drawCell: function (i, j) &#123;
    var item =
      &#39;&lt;div class=&quot;number_cell pos&#39; + i +
      j + &#39;&quot; &gt;&lt;a class=&quot;number_cell_con n&#39; +
      this.arr[i][j].value +
      &#39;&quot;&gt;&lt;div class=&quot;span_wrap&quot;&gt;&lt;span&gt;&#39; +
      this.arr[i][j].value +
      &quot;&lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;&quot;;
    $(&quot;.box&quot;).append(item);
  &#125;,
</code></pre>
<p>在这些函数的协同工作下，只需要服务端发来减小请求，即可使得另一端出现最大值减半的惩罚。</p>
</li>
<li><h4 id="展示双方互动消息"><a href="#展示双方互动消息" class="headerlink" title="展示双方互动消息"></a>展示双方互动消息</h4><p>本来在这里的本意是设计一个简单的聊天窗口，但是能力有限所以只能设计一个简单的消息抖动</p>
<pre><code class="javascript">function Notice(num) &#123;
  var item =
    &#39;&lt;div class=&quot;news_head&quot;&gt;警告&lt;/div&gt;&#39; +
    &#39;&lt;div class=&quot;news_content&quot;&gt;对面已经生成 &#39; +
    num + &quot; 辣! 你的最大值被干掉了 ╥﹏╥&lt;/div&gt;&quot;;
  $(&quot;.news&quot;).append(item);
  setTimeout(function () &#123;
    $(&quot;.news&quot;).empty(item);
  &#125;, 500);
  setTimeout(function () &#123;
    $(&quot;.news&quot;).append(item);
  &#125;, 1000);
  setTimeout(function () &#123;
    $(&quot;.news&quot;).empty(item);
  &#125;, 1500);
  setTimeout(function () &#123;
    $(&quot;.news&quot;).append(item);
  &#125;, 2000);
  setTimeout(function () &#123;
    $(&quot;.news&quot;).empty(item);
  &#125;, 2500);
  setTimeout(function () &#123;
    $(&quot;.news&quot;).append(item);
  &#125;, 3000);
  setTimeout(function () &#123;
    $(&quot;.news&quot;).empty(item);
  &#125;, 6500);
&#125;
</code></pre>
<p>不得不说这真的是一个非常傻瓜的办法来实现跳动的消息，不仅7次调用了DOM，还把整个代码显得非常冗长。但是用一个高情商的说法来说的话，<del>其实这里体现了面向过程的编程思想</del>。不过像这样的效果实际上不必要这样实现，现在我觉得最好的方法应该是通过CSS来实现即可。</p>
<pre><code class="css">@keyframes fade &#123;
    from &#123; opacity: 1.0; &#125;
    50% &#123; opacity: 0.4; &#125;
    to &#123; opacity: 1.0; &#125;
&#125;

@-webkit-keyframes fade &#123;
    from &#123; opacity: 1.0; &#125;
    50% &#123; opacity: 0.4; &#125;
    to &#123; opacity: 1.0; &#125;
&#125;
.news &#123;
    height: 90%;
    width: 90%;
    border-radius: 8%;
    border: #af9b81d8 solid 2px;
    background-color: rgba(255, 245, 221, 0.712);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    animation: fade 1000ms infinite;
    -webkit-animation: fade 1000ms infinite;
&#125;
</code></pre>
<p>如上就可以实现我需要的news出现一个闪烁的效果了。</p>
</li>
</ol>
<p>虽然说从这里看下来，每一个项目的难点实现下来都有很大的提升空间，但我觉得我们能够在短时间内了解新的技术并实现这些功能就已经很好了，所以最终的结果也非常令人满意。总的来说，JQuery虽然是过去最常用到的一项前端技术，但是随着时代的更迭确实出现了这样那样的问题，在这个项目里也体现了出来。所以我认为，JQuery的衰退或许是必然的，作为一个程序员，还是要不断提升自己的知识，不断学习才行，因为哪怕是曾经风靡一时乃至占有率超高的技术，也有可能会像Flash、JQuery一样消失在时代的洪流中，谁能说哪怕当今最热门的 React 和 Vue 就一定不会被未来的技术淘汰呢？</p>

            </div>

            <!-- Post Comments -->
            

        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
