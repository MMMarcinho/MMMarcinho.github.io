<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Marco's Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="方正 Marco" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Marco</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/mmmarco" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="https://www.zju.edu.cn" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://z3.ax1x.com/2021/06/10/22FksP.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >LeetCode - Hot 100 刷题记录</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h3><blockquote>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。</p>
<p>  输入：nums = [2,7,11,15], target = 9<br>        输出：[0,1]<br>        解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] </p>
<p>  输入：nums = [3,2,4], target = 6<br>        输出：[1,2]</p>
<p> 来源：力扣（LeetCode）链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a></p>
</blockquote>
<p>这题在LeetCode上已经被写出花来了，仔细一看是LeetCode第一题那也难怪。</p>
<p>最简单的思路其实刚学过C语言的同学就能写了，就是进行一个循环遍历，找出那两个值，这样时间复杂度直接变成O(N^2)，虽然好像没有浪费额外的空间，但是面试的时候这样写说不定直接被当成大一学生抬走了。</p>
<h4 id="使用哈希表"><a href="#使用哈希表" class="headerlink" title="使用哈希表"></a>使用哈希表</h4><p>这个做法非常亲民，想到的难度也不高，只需要使用哈希表来存储每一个数字的下标，并根据当前值计算是否存在另一个与之能满足和的下标即可。</p>
<pre><code class="c++">class Solution &#123;
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;
        unordered_map&lt;int, int&gt; mp;
        for (int i = 0; i &lt; nums.size(); i ++)
        &#123;
            if (mp.count(target - nums[i]))
                return &#123;mp[target - nums[i]], i&#125;;
            mp[nums[i]] = i;
        &#125;
        return &#123;&#125;;
    &#125;
&#125;;
</code></pre>
<p>时间复杂度：O(N)，N 是数组中的元素数量</p>
<p>空间复杂度：O(N)，其中 N 是数组中的元素数量，主要是因为哈希表。</p>
<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h3><blockquote>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p>  输入：head = [1,2,3,4,5]<br>        输出：[5,4,3,2,1]</p>
<p>  输入：head = [1,2]<br>        输出：[2,1]</p>
</blockquote>
<p>这是一道曾经令我苦不堪言的问题，因为这道题对于当时初学数据结构的我来说实在是太抽象了，还记得疫情期间在家学习数据结构因为这道题冥思苦想了很久。</p>
<p>但实际上这道题也是有很多方法可以完成了，而且这题作为一个基本的功能实际上在很多进阶的题目里也其实可以利用一番，最重要的是它巧妙地利用了链表的性质，完成了对链表的反转，思维很巧妙。</p>
<h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><pre><code class="c++">class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        if (head == nullptr || head-&gt;next == nullptr)
            return head;
        ListNode* temp = reverseList(head-&gt;next);
        ListNode* p = head-&gt;next;
        head-&gt;next = p-&gt;next;
        p-&gt;next = head;
        return temp;
    &#125;
&#125;;
</code></pre>
<p>其实递归的思路很适合用在链表和树的问题中。递归的思路一直都是，先写出递归结束的条件。这里因为如果链表长度仅为 1 的时候是无法继续往下递归的，所以链表在head-&gt;next为空的时候也要停止递归，并返回head。在判断结束之后就将除了head以外的反转结果当作一个新的链表结点temp，此时理论上temp指向的已经是最开始的链表的最后一个元素了，因为经过递归之后最后一个元素理论上才是现在被temp指向的那个元素。但head此时指向的next仍然是最开始的那个元素，也就是temp指向的顺序里的最后一个，这时候就需要把它们的指向反转，也就是head的next指向最后一位的next（也就是代码里的p的next == nullptr），然后再让p的next指向head，最后返回的链表是temp即可。</p>
<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h3><blockquote>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储<strong>一位</strong>数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p> 来源：力扣（LeetCode）<br>        链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a></p>
<p> 输入：l1 = [2,4,3], l2 = [5,6,4]<br>        输出：[7,0,8]<br>        解释：342 + 465 = 807.</p>
<p> 输入：l1 = [0], l2 = [0]<br>        输出：[0]</p>
</blockquote>
<p>这道题的难度并不大，但是要考虑周全需要写的代码就比较长了。同时这道题目里面有一个大坑，就是它的链表居然是反着表示一个数字的。例如：2 -&gt; 4 -&gt; 3，并不是243，而是342。虽然这样的设置对解题者来说实际上是降低了难度，但是也造成了我根本没想到居然会有这样的设计。</p>
<p>但是整道题的难度不大，如果面试的时候考这道题目也太中奖了吧。</p>
<pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;
        ListNode* res = new ListNode(-1);
        ListNode* ret = res;
        int carry = 0, sum;
        while (l1 != nullptr &amp;&amp; l2 != nullptr)
        &#123;
            sum = (l1-&gt;val + l2-&gt;val + carry) % 10;
            ListNode* p = new ListNode(sum);
            res-&gt;next = p;
            carry = (l1-&gt;val + l2-&gt;val + carry) / 10;
            l1 = l1-&gt;next;
            l2 = l2-&gt;next;
            res = res-&gt;next;
            res-&gt;next = nullptr;
        &#125;
        while (l1 != nullptr)
        &#123;
            sum = (l1-&gt;val + carry) % 10;
            carry = (l1-&gt;val + carry) / 10;
            ListNode* p = new ListNode(sum);
            res-&gt;next = p;
            l1 = l1-&gt;next;
            res = res-&gt;next;
            res-&gt;next = nullptr;
        &#125;
        while (l2 != nullptr)
        &#123;
            sum = (l2-&gt;val + carry) % 10;
            carry = (l2-&gt;val + carry) / 10;
            ListNode* p = new ListNode(sum);
            res-&gt;next = p;
            l2 = l2-&gt;next;
            res = res-&gt;next;
            res-&gt;next = nullptr;
        &#125;
        if (carry &gt; 0)
        &#123;
            ListNode* p = new ListNode(carry);
            res-&gt;next = p;
            res = res-&gt;next;
            res-&gt;next = nullptr;
        &#125;
        return ret-&gt;next;
    &#125;
&#125;;
</code></pre>
<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h3><blockquote>
<p> 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p> 有效字符串需满足：</p>
<p> 左括号必须用相同类型的右括号闭合。<br>        左括号必须以正确的顺序闭合。</p>
<p> 来源：力扣（LeetCode）<br>        链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses">https://leetcode-cn.com/problems/valid-parentheses</a></p>
<p> 输入：s = “()”<br>        输出：true</p>
<p> 输入：s = “()[]{}”<br>        输出：true</p>
</blockquote>
<p>这道题之前有一章很详细的 <strong><a target="_blank" rel="noopener" href="http://marcooouri.top/2021/05/25/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E4%BB%A5%E5%8F%8A%E5%A0%86%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8/">博客</a></strong> 讲解过了，还讲到了其中的一些变形和难度增加的题目。</p>
<pre><code class="c++">class Solution &#123;
public:
    bool isValid(string s) &#123;
        stack&lt;int&gt; st;
        for (int i = 0; i &lt; s.size(); i ++)
        &#123;
            if (s[i] == &#39;(&#39; || s[i] == &#39;[&#39; || s[i] == &#39;&#123;&#39;)
                st.push(s[i]);
            else if (s[i] == &#39;)&#39;)
            &#123;
                if (st.empty() || st.top() != &#39;(&#39;)
                    return false;
                st.pop();
            &#125;
            else if (s[i] == &#39;]&#39;)
            &#123;
                if (st.empty() || st.top() != &#39;[&#39;)
                    return false;
                st.pop();
            &#125;
            else if (s[i] == &#39;&#125;&#39;)
            &#123;
                if (st.empty() || st.top() != &#39;&#123;&#39;)
                    return false;
                st.pop();
            &#125;
        &#125; 
        return st.empty();
    &#125;
&#125;;
</code></pre>
<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3><blockquote>
<p> 给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p> 输入: s = “abcabcbb”<br>        输出: 3<br>        解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
</blockquote>
<pre><code class="c++">
</code></pre>
<h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h3><blockquote>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p> 输入：s = “babad”<br>        输出：”bab”<br>        解释：”aba” 同样是符合题意的答案。</p>
<p> 输入：s = “cbbd”<br>        输出：”bb”</p>
<p> 输入：s = “a”<br>        输出：”a”</p>
</blockquote>
<p>在剑指Offer里应该就刷到过这道题，给当时的我留下了很深的印象。其实这道题也不能算是在考察字符串的能力，最根本的还是在考察动态规划的能力。动态规划算是一个常考的点了，去年认真刷了很多关于动态规划的题目，最后终于有所感悟，然后今年因为一些事情没有去复习于是又忘得差不多了……</p>
<p>这里需要使用动态规划的思想，设置一个二维dp数组，这个二维数组代表了从 i 到 j 是否为回文字符串，若是则为<code>true</code>。至于如何判断是否为回文字符串，则要分不同情况进行处理。</p>

            </div>

            <!-- Post Comments -->
            

        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
