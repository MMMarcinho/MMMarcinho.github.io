<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Marco's Blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="方正 Marco" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Marco</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/mmmarco" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="https://www.zju.edu.cn" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://z3.ax1x.com/2021/06/10/22FksP.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >LeetCode - Hot 100 刷题记录</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h3><blockquote>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。</p>
<p>  输入：nums = [2,7,11,15], target = 9<br>        输出：[0,1]<br>        解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] </p>
<p>  输入：nums = [3,2,4], target = 6<br>        输出：[1,2]</p>
<p> 来源：力扣（LeetCode）链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a></p>
</blockquote>
<p>这题在LeetCode上已经被写出花来了，仔细一看是LeetCode第一题那也难怪。</p>
<p>最简单的思路其实刚学过C语言的同学就能写了，就是进行一个循环遍历，找出那两个值，这样时间复杂度直接变成O(N^2)，虽然好像没有浪费额外的空间，但是面试的时候这样写说不定直接被当成大一学生抬走了。</p>
<h4 id="使用哈希表"><a href="#使用哈希表" class="headerlink" title="使用哈希表"></a>使用哈希表</h4><p>这个做法非常亲民，想到的难度也不高，只需要使用哈希表来存储每一个数字的下标，并根据当前值计算是否存在另一个与之能满足和的下标即可。</p>
<pre><code class="c++">class Solution &#123;
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;
        unordered_map&lt;int, int&gt; mp;
        for (int i = 0; i &lt; nums.size(); i ++)
        &#123;
            if (mp.count(target - nums[i]))
                return &#123;mp[target - nums[i]], i&#125;;
            mp[nums[i]] = i;
        &#125;
        return &#123;&#125;;
    &#125;
&#125;;
</code></pre>
<p>时间复杂度：O(N)，N 是数组中的元素数量</p>
<p>空间复杂度：O(N)，其中 N 是数组中的元素数量，主要是因为哈希表。</p>
<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h3><blockquote>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p>  输入：head = [1,2,3,4,5]<br>        输出：[5,4,3,2,1]</p>
<p>  输入：head = [1,2]<br>        输出：[2,1]</p>
</blockquote>
<p>这是一道曾经令我苦不堪言的问题，因为这道题对于当时初学数据结构的我来说实在是太抽象了，还记得疫情期间在家学习数据结构因为这道题冥思苦想了很久。</p>
<p>但实际上这道题也是有很多方法可以完成了，而且这题作为一个基本的功能实际上在很多进阶的题目里也其实可以利用一番，最重要的是它巧妙地利用了链表的性质，完成了对链表的反转，思维很巧妙。</p>
<h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><pre><code class="c++">class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        if (head == nullptr || head-&gt;next == nullptr)
            return head;
        ListNode* temp = reverseList(head-&gt;next);
        ListNode* p = head-&gt;next;
        head-&gt;next = p-&gt;next;
        p-&gt;next = head;
        return temp;
    &#125;
&#125;;
</code></pre>
<p>其实递归的思路很适合用在链表和树的问题中。递归的思路一直都是，先写出递归结束的条件。这里因为如果链表长度仅为 1 的时候是无法继续往下递归的，所以链表在head-&gt;next为空的时候也要停止递归，并返回head。在判断结束之后就将除了head以外的反转结果当作一个新的链表结点temp，此时理论上temp指向的已经是最开始的链表的最后一个元素了，因为经过递归之后最后一个元素理论上才是现在被temp指向的那个元素。但head此时指向的next仍然是最开始的那个元素，也就是temp指向的顺序里的最后一个，这时候就需要把它们的指向反转，也就是head的next指向最后一位的next（也就是代码里的p的next == nullptr），然后再让p的next指向head，最后返回的链表是temp即可。</p>
<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h3><blockquote>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储<strong>一位</strong>数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p> 来源：力扣（LeetCode）<br>        链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a></p>
<p> 输入：l1 = [2,4,3], l2 = [5,6,4]<br>        输出：[7,0,8]<br>        解释：342 + 465 = 807.</p>
<p> 输入：l1 = [0], l2 = [0]<br>        输出：[0]</p>
</blockquote>
<p>这道题的难度并不大，但是要考虑周全需要写的代码就比较长了。同时这道题目里面有一个大坑，就是它的链表居然是反着表示一个数字的。例如：2 -&gt; 4 -&gt; 3，并不是243，而是342。虽然这样的设置对解题者来说实际上是降低了难度，但是也造成了我根本没想到居然会有这样的设计。</p>
<p>但是整道题的难度不大，如果面试的时候考这道题目也太中奖了吧。</p>
<pre><code class="c++">class Solution &#123;
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;
        ListNode* res = new ListNode(-1);
        ListNode* ret = res;
        int carry = 0, sum;
        while (l1 != nullptr &amp;&amp; l2 != nullptr)
        &#123;
            sum = (l1-&gt;val + l2-&gt;val + carry) % 10;
            ListNode* p = new ListNode(sum);
            res-&gt;next = p;
            carry = (l1-&gt;val + l2-&gt;val + carry) / 10;
            l1 = l1-&gt;next;
            l2 = l2-&gt;next;
            res = res-&gt;next;
            res-&gt;next = nullptr;
        &#125;
        while (l1 != nullptr)
        &#123;
            sum = (l1-&gt;val + carry) % 10;
            carry = (l1-&gt;val + carry) / 10;
            ListNode* p = new ListNode(sum);
            res-&gt;next = p;
            l1 = l1-&gt;next;
            res = res-&gt;next;
            res-&gt;next = nullptr;
        &#125;
        while (l2 != nullptr)
        &#123;
            sum = (l2-&gt;val + carry) % 10;
            carry = (l2-&gt;val + carry) / 10;
            ListNode* p = new ListNode(sum);
            res-&gt;next = p;
            l2 = l2-&gt;next;
            res = res-&gt;next;
            res-&gt;next = nullptr;
        &#125;
        if (carry &gt; 0)
        &#123;
            ListNode* p = new ListNode(carry);
            res-&gt;next = p;
            res = res-&gt;next;
            res-&gt;next = nullptr;
        &#125;
        return ret-&gt;next;
    &#125;
&#125;;
</code></pre>
<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h3><blockquote>
<p> 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p> 有效字符串需满足：</p>
<p> 左括号必须用相同类型的右括号闭合。<br>        左括号必须以正确的顺序闭合。</p>
<p> 来源：力扣（LeetCode）<br>        链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses">https://leetcode-cn.com/problems/valid-parentheses</a></p>
<p> 输入：s = “()”<br>        输出：true</p>
<p> 输入：s = “()[]{}”<br>        输出：true</p>
</blockquote>
<p>这道题之前有一章很详细的 <strong><a target="_blank" rel="noopener" href="http://marcooouri.top/2021/05/25/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E4%BB%A5%E5%8F%8A%E5%A0%86%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8/">博客</a></strong> 讲解过了，还讲到了其中的一些变形和难度增加的题目。</p>
<pre><code class="c++">class Solution &#123;
public:
    bool isValid(string s) &#123;
        stack&lt;int&gt; st;
        for (int i = 0; i &lt; s.size(); i ++)
        &#123;
            if (s[i] == &#39;(&#39; || s[i] == &#39;[&#39; || s[i] == &#39;&#123;&#39;)
                st.push(s[i]);
            else if (s[i] == &#39;)&#39;)
            &#123;
                if (st.empty() || st.top() != &#39;(&#39;)
                    return false;
                st.pop();
            &#125;
            else if (s[i] == &#39;]&#39;)
            &#123;
                if (st.empty() || st.top() != &#39;[&#39;)
                    return false;
                st.pop();
            &#125;
            else if (s[i] == &#39;&#125;&#39;)
            &#123;
                if (st.empty() || st.top() != &#39;&#123;&#39;)
                    return false;
                st.pop();
            &#125;
        &#125; 
        return st.empty();
    &#125;
&#125;;
</code></pre>
<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3><blockquote>
<p> 给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p> 输入: s = “abcabcbb”<br>         输出: 3<br>         解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
</blockquote>
<p>这道题用到了回溯法。本来以为自己使用的是动态规划，后来发现这题回溯法实际上效率也很高。使用一个dp数组来表示到该字符串最长可能的不含重复字符串的长度为多少。每一次取前一个最长字符串的长度，然后向前回溯，如果不相等则可以使dp数组 + 1，若相等则停止回溯。</p>
<pre><code class="c++">class Solution &#123;
public:
    int lengthOfLongestSubstring(string s) &#123;
        int size = s.size();
        if (size &lt;= 1)
            return size;
        vector&lt;int&gt; dp(size, 1);
        for (int i = 1; i &lt; size; i ++)
        &#123;
            int backLen = dp[i - 1], j = i - 1;
            for (; j &gt; i - backLen - 1; j --)
            &#123;
                if (s[j] != s[i])
                    dp[i] ++;
                else
                    break;
            &#125; 
        &#125;
        int res = INT_MIN;
        for (int i = 0; i &lt; size; i ++)
            res = max(res, dp[i]);
        return res;
    &#125;
&#125;;
</code></pre>
<h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h3><blockquote>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p> 输入：s = “babad”<br>        输出：”bab”<br>        解释：”aba” 同样是符合题意的答案。</p>
<p> 输入：s = “cbbd”<br>        输出：”bb”</p>
<p> 输入：s = “a”<br>        输出：”a”</p>
</blockquote>
<p>在剑指Offer里应该就刷到过这道题，给当时的我留下了很深的印象。其实这道题也不能算是在考察字符串的能力，最根本的还是在考察动态规划的能力。动态规划算是一个常考的点了，去年认真刷了很多关于动态规划的题目，最后终于有所感悟，然后今年因为一些事情没有去复习于是又忘得差不多了……</p>
<p>之前使用了动态规划的思想，设置一个二维dp数组，这个二维数组代表了从 i 到 j 是否为回文字符串，若是则为<code>true</code>。至于如何判断是否为回文字符串，则要分不同情况进行处理。</p>
<p>但是后来发现这个方法效率不高，可以进行一系列的优化，最后根据评论区大神的代码，修改了自己的。</p>
<pre><code class="c++">class Solution &#123;
public:
    string longestPalindrome(string s) &#123;
        int size = s.size();
        if (size &lt;= 1)
            return s;
        int start = 0, maxLen = 0, i = 0;
        while (s[i])
        &#123;
            int l = i, r = i;
            while (r + 1 &lt; size &amp;&amp; s[r + 1] == s[r])
                r ++;
            i = r + 1;
            while (l - 1 &gt;= 0 &amp;&amp; r + 1 &lt; size &amp;&amp; s[r + 1] == s[l - 1])
            &#123;
                l --;
                r ++;
            &#125;
            if (r - l + 1 &gt; maxLen) &#123;
                maxLen = r - l + 1;
                start = l;
            &#125;
        &#125;
        return s.substr(start, maxLen);
    &#125;
&#125;;
</code></pre>
<p>这个方法显然比之前使用动态规划的方法要简单很多，但是思路没有之前那么清晰。首先进入while循环之后，先选取下标为 i 的元素为基准。根据 i 进行两侧展开。第一个while循环中，先向右扩展。但是因为是单边扩展的，所以只有是与基准的字符相同才会扩展。之后将基准 i 定在边界的右侧，此时基准肯定与之前的字符是不一样的，所以开始向左侧扩展。当左右字符相同的情况下，可以向两侧扩展一位。当这次while循环结束之后，将左右两侧下标相减并得到一个长度，与目前最长长度作比较，若更大则更新目前最长长度，并将记录下最左侧的下标。最后返回字符串的一部分即可。</p>
<h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><blockquote>
<p> 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p> 进阶：你能尝试使用一趟扫描实现吗？</p>
<p> 输入：head = [1,2,3,4,5], n = 2<br>        输出：[1,2,3,5]</p>
<p> 输入：head = [1], n = 1<br>        输出：[]</p>
<p> 输入：head = [1,2], n = 1<br>        输出：[1]</p>
</blockquote>
<p>关于链表的问题，尤其是要牵扯到从后往前数数的问题，最好的办法绝对不是把链表变成数组，也不是把从前往后先数一下有几位，而是使用双指针。双指针的用法一般有快慢指针和一个指针先出发再另一个指针出发。</p>

            </div>

            <!-- Post Comments -->
            

        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
